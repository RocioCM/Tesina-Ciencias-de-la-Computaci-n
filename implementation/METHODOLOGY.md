# Metodología de trabajo

Para definir la metodología de trabajo para el desarrollo de software de este trabajo de tesis, se tuvieron en cuenta los siguientes aspectos:

- Objetivos del trabajo de tesis
- Planificación de actividades
- Alcance del prototipo
- Definición de requerimientos funcionales y no funcionales
- Modalidad de entrega de resultados
- Equipo de trabajo

Se revisaron diferentes metodologías de trabajo para el desarrollo de software, incluyendo metodologías de trabajo tradicionales y metodologías ágiles para determinar cuál se ajusta mejor a este proyecto. Tras la revisión general, comparamos en distintos aspectos claves 4 metodologías que consideramos más adecuadas para el desarrollo de software de este trabajo de tesis. Las metodologías revisadas fueron:

- Metodología en cascada
- Metodología en espiral
- Medología Scrum
- Medología Kanban
- Metodología en V

Aquí tienes una tabla comparativa enfocada en **Ágil (Scrum y Kanban)**, **Cascada**, **Modelo en V** y **Espiral**, abordando los factores clave para cada metodología:

| **Aspecto/Metodología** | **Ágil (Scrum)** | **Ágil (Kanban)** | **Cascada** | **Modelo en V** | **Espiral** |
| --- | --- | --- | --- | --- | --- |
| **Naturaleza del Proyecto** | Ideal para proyectos con requisitos cambiantes y evolución constante. | Proyectos que requieren flujo continuo y flexibilidad para gestionar tareas cambiantes. | Adecuado para proyectos con requisitos claros y definidos desde el principio. | Proyectos de alta criticidad, con un enfoque riguroso en calidad y validación. | Proyectos grandes y complejos, con alto riesgo y múltiples iteraciones. |
| **Requisitos del Cliente** | Requisitos pueden cambiar en cada sprint, permite la interacción continua con el cliente. | Requisitos pueden ajustarse de manera continua según la demanda y prioridades. | Requisitos fijos desde el inicio, cualquier cambio implica un costo significativo. | Requisitos claros desde el inicio, con verificación constante. | Requisitos pueden refinarse en cada iteración, ideal para proyectos con incertidumbre. |
| **Tamaño del Equipo** | Equipos pequeños (idealmente 5-9 personas) colaborativos y multidisciplinarios. | Equipos pequeños a medianos, más flexibles en tamaño, ajustando tareas según flujo de trabajo. | Equipos medianos a grandes, con roles bien definidos y fases claras. | Equipos medianos a grandes, con roles especializados para cada fase. | Equipos medianos a grandes, flexibles en roles según los ciclos de iteración y gestión de riesgos. |
| **Cultura Organizacional** | Cultura colaborativa, centrada en la mejora continua y la autoorganización. | Cultura flexible y adaptable, con enfoque en la optimización del flujo de trabajo. | Cultura jerárquica y estructurada, con fases bien definidas. | Cultura disciplinada y centrada en la calidad, con un fuerte enfoque en la validación y verificación. | Cultura orientada a la gestión del riesgo y adaptación a cambios continuos en cada iteración. |
| **Flexibilidad en Gestión** | Alta flexibilidad para adaptarse a los cambios durante cada sprint (iteración). | Alta flexibilidad en la gestión del flujo, ajustando la carga de trabajo en función de las prioridades. | Baja flexibilidad, difícil de cambiar una vez iniciado el proyecto. | Flexibilidad moderada, cambios difíciles una vez avanzado el proyecto. | Alta flexibilidad, con ciclos iterativos que permiten gestionar cambios de forma continua. |
| **Documentación** | Documentación mínima, suficiente para facilitar la entrega de valor funcional. | Documentación mínima, enfocada en la visualización del flujo y el progreso. | Documentación detallada en cada fase del ciclo de vida del desarrollo. | Documentación extensa, especialmente en fases de pruebas y validación. | Documentación formal en cada iteración para gestionar riesgos y validar avances. |
| **Riesgos y Control de Calidad** | Los riesgos se manejan en cada sprint, se realizan pruebas y ajustes continuos. | Control continuo del flujo de trabajo, evitando cuellos de botella. Riesgo gestionado al ajustar el WIP (Work In Progress). | Riesgo alto si los requisitos cambian, control de calidad al final del ciclo. | Riesgo bajo, con verificación y validación constante en cada fase. | Riesgo bajo, diseñado específicamente para gestionar riesgos en cada iteración. |
| **Entregas al Cliente** | Entregas frecuentes (cada sprint), con incrementos de software funcional. | Entregas continuas, en función de la finalización de tareas o según demanda. | Una única entrega al final del proyecto. | Una única entrega al final, con validación en cada fase. | Entregas iterativas, con revisiones parciales hasta completar el proyecto. |
| **Curva de Aprendizaje** | Media. Requiere adaptación a la metodología y roles dentro del equipo (Scrum Master, Product Owner). | Baja. Fácil de implementar, basado en la mejora continua del flujo de trabajo. | Baja. Fácil de comprender, pero difícil de ajustar a cambios durante el ciclo. | Media. Se requiere disciplina en verificación y validación. | Alta. Complejidad en la gestión del riesgo y las iteraciones continuas. |
| **Velocidad de Desarrollo** | Alta. Las iteraciones cortas permiten entregas rápidas y ajustes según retroalimentación. | Alta. Flujo continuo de desarrollo, ajustando la velocidad según las prioridades. | Baja a media. El ciclo es largo debido a la rigidez en las fases. | Media. Las fases de validación pueden ralentizar el desarrollo. | Media. El proceso iterativo es más largo por la gestión de riesgos y planificación. |
| **Manejo de Cambios** | Cambios fáciles de gestionar en cada sprint, se ajusta según las prioridades del cliente. | Los cambios se gestionan en función de la demanda, ajustando tareas en el flujo de trabajo. | Cambios difíciles y costosos de implementar una vez que el proyecto ha avanzado. | Los cambios son complicados, requieren revalidación constante. | Cambios gestionados de manera continua en cada ciclo, permitiendo ajustes según los riesgos. |
| **Manejo de Riesgos** | Riesgos gestionados en cada sprint, con retrospectivas que permiten mejoras continuas. | Riesgos manejados de manera continua, ajustando el flujo y reduciendo cuellos de botella. | Riesgo alto, ya que los problemas suelen descubrirse al final, durante la fase de prueba. | Riesgo bajo, debido a la verificación y validación constantes en cada fase. | Riesgo bajo, diseñado para gestionar riesgos en cada iteración de manera efectiva. |

En base al análisis realizado, se optó por la metodología de desarrollo tradicional en V junto con el uso de Kanban para la gestión de tareas y el seguimiento del flujo de trabajo. Se eligió utilizar una metodología de desarrollo tradicional dado que el alcance del proyecto es claro y no se esperan cambios significativos en los requerimientos y se busca dejar una gran cantidad de documentación para futuras iteraciones del proyecto.

En primer lugar, se descartó el uso de Scrum dado que sus fortalezas se encuentran en la entrega de valor funcional en cada sprint, lo cual no es necesario en este proyecto y requiere una fuerte presencia del cliente o el Product Owner durante el desarrollo, lo cual no es posible en este caso. A su vez, esta metodología require una definición de roles y responsabilidades que no se ajustan a la estructura del equipo de trabajo de este proyecto al ser muy pequeño y no contar con roles específicos como Scrum Master o Product Owner. También scrum requiere de una serie de reuniones diarias, semanales y mensuales que cobran mayor sentido en proyectos con equipos más grandes con mayor cantidad de roles y responsabilidades y necesidad de sincronización constante.

Por otro lado, se descartó el uso de la metodología en espiral debido a que su enfoque en la gestión de riesgos y la adaptación a cambios continuos no es tan relevante en este proyecto. De modo que únicamente agregaría complejidad y tiempo al desarrollo sin aportar un valor significativo ya que el riesgo y la incertidumbre en este proyecto son bajos.

Tanto el modelo en cascada como el modelo en V son aplicables en equipos de cualquier tamaño (desde unipersonales hasta grandes equipos) y en proyectos de cualquier envergadura. Ambos modelos se basan en la planificación y la documentación, por lo que son ideales para este proyecto, donde los requerimientos están claramente definidos desde el principio, la probabilidad de cambios y de riesgo es baja ya que se ha hecho una profunda investigación y análisis previo a la definición de requerimientos y la planificación macro de fases se ha armado previa al desarrollo, aunque es flexible a nivel micro-tarea (por eso elegimos combinar con Kanban para la gestión de tareas). Estas metodologías son compatibles con un alto nivel de documentación y validación, lo cual es esencial para este proyecto de tesis, donde se busca dejar un legado de documentación y código para futuras iteraciones y proyectos relacionados. Esto es ventajoso en comparación con las metodologías ágiles, que se centran en la entrega de valor funcional en cada sprint y no contemplan la entrega de una documentación extensa, lo cual no es adecuado para este proyecto.

Ambas metodologías contemplan una única entrega al final del proyecto, lo cual es adecuado para este trabajo de tesis, pero la diferencia radica en que el modelo en V se enfoca en la validación y verificación constante en cada fase, por lo que en cada fase se entrega un módulo de software funcional que es validado y verificado antes de pasar a la siguiente fase, mientras que el modelo en cascada se enfoca en la entrega de un producto final validado y verificado al final del proyecto sin especificar los entregables intermedios.

A su vez, la mayor diferencia entre el modelo en cascada y el modelo en V radica en la forma en que se estructuran las fases del proyecto. En el modelo en cascada, las fases se ejecutan de forma secuencial, una tras otra, sin posibilidad de retroceso, lo cual puede ser una desventaja si se detectan errores o cambios en fases anteriores. En cambio, en el modelo en V, las fases se ejecutan de forma paralela, con validaciones y verificaciones constantes entre fases, lo cual permite detectar errores y cambios de forma temprana y corregirlos antes de avanzar a la siguiente fase. De modo que el modelo en V tolera mejor el riego, dado que es más flexible y adaptable a cambios y errores, lo cual es una ventaja para este proyecto de tesis.

Por estos motivos, se ha elegido el modelo de desarrollo en V para el desarrollo de software de este trabajo de tesis, ya que se ajusta mejor a las necesidades y características del proyecto, permitiendo una planificación clara y estructurada, con una gestión eficiente de tareas y prioridades, manteniendo un enfoque en la entrega de valor y la calidad del software desarrollado. Si bien este modelo agrega una mayor carga al hacer un fuerte foco en las validaciones, garantiza un alto nivel de calidad y confiabilidad en el entregable final de este trabajo.

Se optó por combinar esta metodología con Kanban para la gestión de tareas y el seguimiento del flujo de trabajo durante el desarollo ya que permite una mayor flexibilidad en la gestión de micro-tareas y prioridades. Además, Kanban es una metodología más ligera y fácil de implementar, lo cual se ajusta a las necesidades del pequeño equipo de trabajo de este proyecto y permite mantener en vista el avance del proyecto de manera visual y sencilla, facilitando el seguimiento del progreso por parte del tutor y el estudiante.

En resumen, la metodología de trabajo para el desarrollo de software de este trabajo de tesis será una combinación de una metodología de desarrollo tradicional junto con el uso de Kanban para la gestión de tareas y el seguimiento del flujo de trabajo. Esto permitirá una planificación clara y estructurada, con una gestión eficiente de tareas y prioridades, manteniendo un enfoque en la entrega de valor y la calidad del software desarrollado.
