Los modelos de proceso prescriptivo fueron propuestos originalmente para poner orden en el caos del desarrollo de software. La historia indica que estos modelos tradicionales han dado cierta estructura útil al trabajo de ingeniería de software y que constituyen un mapa razonable- mente eficaz para los equipos de software. Sin embargo, el trabajo de ingeniería de software y el producto que genera siguen “al borde del caos”. El borde del caos se define como “el estado natural entre el orden y el caos, un compromiso grande entre la estructura y la sorpresa” [Kau95]. El borde del caos se visualiza como un estado inestable y parcialmente estructurado […] Es inestable debido a que se ve atraído constantemente hacia el caos o hacia el orden absoluto. Tenemos la tendencia de pensar que el orden es el estado ideal de la naturaleza. Esto podría ser un error […] las investigaciones apoyan la teoría de que la operación que se aleja del equilibrio genera creatividad, procesos autoorganizados y rendimientos crecientes [Roo96]. El orden absoluto significa ausencia de variabilidad, que podría ser una ventaja en los ambientes impredecibles. El cambio ocurre cuando hay cierta estructura que permita que el cambio pueda organizarse, pero que no sea tan rígi- da como para que no pueda suceder. Por otro lado, demasiado caos hace imposible la coordinación y la coherencia. La falta de estructura no siempre significa desorden. Las implicaciones filosóficas de este argumento son significativas para la ingeniería de software. Si los modelos de proceso prescriptivo5 buscan generar estructura y orden, ¿son inapropiados para el mundo del software, que se basa en el cambio? Pero si rechazamos los modelos de pro- ceso tradicional (y el orden que implican) y los reemplazamos con algo menos estructurado, ¿hacemos imposible la coordinación y coherencia en el trabajo de software? No hay respuestas fáciles para estas preguntas, pero existen alternativas disponibles para los ingenieros de software. En las secciones que siguen se estudia el enfoque de proceso prescrip- tivo en el que los temas dominantes son el orden y la consistencia del proyecto. El autor los llama “prescriptivos” porque prescriben un conjunto de elementos del proceso: actividades es- tructurales, acciones de ingeniería de software, tareas, productos del trabajo, aseguramiento de la calidad y mecanismos de control del cambio para cada proyecto. Cada modelo del proceso también prescribe un flujo del proceso (también llamado flujo de trabajo), es decir, la manera en la que los elementos del proceso se relacionan entre sí. Todos los modelos del proceso del software pueden incluir las actividades estructurales ge- nerales descritas en el capítulo 1, pero cada una pone distinto énfasis en ellas y define en forma diferente el flujo de proceso que invoca cada actividad estructural (así como acciones y tareas de ingeniería de software).

Modelo de la cascada

Hay veces en las que los requerimientos para cierto problema se comprenden bien: cuando el trabajo desde la comunicación hasta el despliegue fluye en forma razonablemente lineal. Esta situación se encuentra en ocasiones cuando deben hacerse adaptaciones o mejoras bien defi- nidas a un sistema ya existente (por ejemplo, una adaptación para software de contabilidad que es obligatorio hacer debido a cambios en las regulaciones gubernamentales). También ocurre en cierto número limitado de nuevos esfuerzos de desarrollo, pero sólo cuando los requerimien- tos están bien definidos y tienen una estabilidad razonable.

El modelo de la cascada, a veces llamado ciclo de vida clásico, sugiere un enfoque sistemático y secuencial 6 para el desarrollo del software, que comienza con la especificación de los reque- rimientos por parte del cliente y avanza a través de planeación, modelado, construcción y des- pliegue, para concluir con el apoyo del software terminado (véase la figura 2.3). Una variante de la representación del modelo de la cascada se denomina modelo en V. En la figura 2.4 se ilustra el modelo en V [Buc99], donde se aprecia la relación entre las acciones para el aseguramiento de la calidad y aquellas asociadas con la comunicación, modelado y construc- ción temprana. A medida que el equipo de software avanza hacia abajo desde el lado izquierdo de la V, los requerimientos básicos del problema mejoran hacia representaciones técnicas cada vez más detalladas del problema y de su solución. Una vez que se ha generado el código, el equipo sube por el lado derecho de la V, y en esencia ejecuta una serie de pruebas (acciones para asegurar la calidad) que validan cada uno de los modelos creados cuando el equipo fue hacia abajo por el lado izquierdo.7 En realidad, no hay diferencias fundamentales entre el ciclo de vida clásico y el modelo en V. Este último proporciona una forma de visualizar el modo de aplicación de las acciones de verificación y validación al trabajo de ingeniería inicial. El modelo de la cascada es el paradigma más antiguo de la ingeniería de software. Sin em- bargo, en las últimas tres décadas, las críticas hechas al modelo han ocasionado que incluso sus defensores más obstinados cuestionen su eficacia [Han95]. Entre los problemas que en ocasio- nes surgen al aplicar el modelo de la cascada se encuentran los siguientes

1. Es raro que los proyectos reales sigan el flujo secuencial propuesto por el modelo. Aun- que el modelo lineal acepta repeticiones, lo hace en forma indirecta. Como resultado, los cambios generan confusión conforme el equipo del proyecto avanza.
2. A menudo, es difícil para el cliente enunciar en forma explícita todos los requerimien- tos. El modelo de la cascada necesita que se haga y tiene dificultades para aceptar la in- certidumbre natural que existe al principio de muchos proyectos.
3. El cliente debe tener paciencia. No se dispondrá de una versión funcional del(de los) programa(s) hasta que el proyecto esté muy avanzado. Un error grande sería desastroso si se detectara hasta revisar el programa en funcionamiento.

En un análisis interesante de proyectos reales, Bradac [Bra94] encontró que la naturaleza lineal del ciclo de vida clásico llega a “estados de bloqueo” en los que ciertos miembros del equipo de proyecto deben esperar a otros a fin de terminar tareas interdependientes. En reali- dad, ¡el tiempo de espera llega a superar al dedicado al trabajo productivo! Los estados de bloqueo tienden a ocurrir más al principio y al final de un proceso secuencial lineal. Hoy en día, el trabajo de software es acelerado y está sujeto a una corriente sin fin de cambios (en las características, funciones y contenido de información). El modelo de la cascada suele ser CAPÍTULO 2 MODELOS DEL PROCESO 35 inapropiado para ese tipo de labor. No obstante, sirve como un modelo de proceso útil en situa- ciones en las que los requerimientos son fijos y el trabajo avanza en forma lineal hacia el final.

Modelos de proceso evolutivo

El software, como todos los sistemas complejos, evoluciona en el tiempo. Es frecuente que los requerimientos del negocio y del producto cambien conforme avanza el desarrollo, lo que hace que no sea realista trazar una trayectoria rectilínea hacia el producto final; los plazos apretados del mercado hacen que sea imposible la terminación de un software perfecto, pero debe lan- zarse una versión limitada a fin de aliviar la presión de la competencia o del negocio; se com- prende bien el conjunto de requerimientos o el producto básico, pero los detalles del producto o extensiones del sistema aún están por definirse. En estas situaciones y otras parecidas se necesita un modelo de proceso diseñado explícitamente para adaptarse a un producto que evo- luciona con el tiempo. Los modelos evolutivos son iterativos. Se caracterizan por la manera en la que permiten desarrollar versiones cada vez más completas del software.

El modelo espiral. Propuesto en primer lugar por Barry Boehm [Boe88], el modelo espiral es un modelo evolutivo del proceso del software y se acopla con la naturaleza iterativa de hacer prototipos con los aspectos controlados y sistémicos del modelo de cascada. Tiene el potencial para hacer un desarrollo rápido de versiones cada vez más completas. Boehm [Boe01a] describe el modelo del modo siguiente: El modelo de desarrollo espiral es un generador de modelo de proceso impulsado por el riesgo, que se usa para guiar la ingeniería concurrente con participantes múltiples de sistemas intensivos en soft- ware. Tiene dos características distintivas principales. La primera es el enfoque cíclico para el creci- miento incremental del grado de definición de un sistema y su implementación, mientras que dismi- nuye su grado de riesgo. La otra es un conjunto de puntos de referencia de anclaje puntual para asegurar el compromiso del participante con soluciones factibles y mutuamente satisfactorias. Con el empleo del modelo espiral, el software se desarrolla en una serie de entregas evolutivas. Durante las primeras iteraciones, lo que se entrega puede ser un modelo o prototipo. En las iteraciones posteriores se producen versiones cada vez más completas del sistema cuya inge- niería se está haciendo. Un modelo en espiral es dividido por el equipo de software en un conjunto de actividades estructurales. Para fines ilustrativos, se utilizan las actividades estructurales generales ya ana- lizadas.9 Cada una de ellas representa un segmento de la trayectoria espiral ilustrada en la figura 2.7. Al comenzar el proceso evolutivo, el equipo de software realiza actividades implícitas en un circuito alrededor de la espiral en el sentido horario, partiendo del centro. El riesgo se considera conforme se desarrolla cada revolución (capítulo 28). En cada paso evolutivo se marcan puntos de referencia puntuales: combinación de productos del trabajo y condiciones que se encuentran a lo largo de la trayectoria de la espiral. El primer circuito alrededor de la espiral da como resultado el desarrollo de una especifica- ción del producto; las vueltas sucesivas se usan para desarrollar un prototipo y, luego, versiones cada vez más sofisticadas del software. Cada paso por la región de planeación da como resul- tado ajustes en el plan del proyecto. El costo y la programación de actividades se ajustan con base en la retroalimentación obtenida del cliente después de la entrega. Además, el gerente del proyecto ajusta el número planeado de iteraciones que se requieren para terminar el software. A diferencia de otros modelos del proceso que finalizan cuando se entrega el software, el modelo espiral puede adaptarse para aplicarse a lo largo de toda la vida del software de cómputo. Entonces, el primer circuito alrededor de la espiral quizá represente un “proyecto de desarrollo del concepto” que comienza en el centro de la espiral y continúa por iteraciones múltiples10 hasta que queda terminado el desarrollo del concepto. Si el concepto va a desarro- llarse en un producto real, el proceso sigue hacia fuera de la espiral y comienza un “proyecto de desarrollo de producto nuevo”. El nuevo producto evolucionará a través de cierto número de iteraciones alrededor de la espiral. Más adelante puede usarse un circuito alrededor de la espiral para que represente un “proyecto de mejora del producto”. En esencia, la espiral, cuando se caracteriza de este modo, sigue operativa hasta que el software se retira. Hay ocasiones en las que el proceso está inmóvil, pero siempre que se inicia un cambio comienza en el punto de entrada apropiado (por ejemplo, mejora del producto). El modelo espiral es un enfoque realista para el desarrollo de sistemas y de software a gran escala. Como el software evoluciona a medida que el proceso avanza, el desarrollador y cliente comprenden y reaccionan mejor ante los riesgos en cada nivel de evolución. El modelo espiral usa los prototipos como mecanismo de reducción de riesgos, pero, más importante, permite aplicar el enfoque de hacer prototipos en cualquier etapa de la evolución del producto. Mantiene el enfoque de escalón sistemático sugerido por el ciclo de vida clásico, pero lo incorpora en una estructura iterativa que refleja al mundo real en una forma más realista. El modelo espiral de- manda una consideración directa de los riesgos técnicos en todas las etapas del proyecto y, si se aplica de manera apropiada, debe reducir los riesgos antes de que se vuelvan un problema. Pero, como otros paradigmas, el modelo espiral no es una panacea. Es difícil convencer a los clientes (en particular en situaciones bajo contrato) de que el enfoque evolutivo es controlable. Demanda mucha experiencia en la evaluación del riesgo y se basa en ella para llegar al éxito. No hay duda de que habrá problemas si algún riesgo importante no se descubre y administra.

Desarrollo agil

En 2001, Kent Beck y otros 16 notables desarrolladores de software, escritores y consulto- res [Bec01a] (grupo conocido como la “Alianza Ágil”) firmaron el “Manifiesto por el desa- rrollo ágil de software”. En él se establecía lo siguiente: Estamos descubriendo formas mejores de desarrollar software, por medio de hacerlo y de dar ayuda a otros para que lo hagan. Ese trabajo nos ha hecho valorar: Los individuos y sus interacciones, sobre los procesos y las herramientas El software que funciona, más que la documentación exhaustiva La colaboración con el cliente, y no tanto la negociación del contrato Responder al cambio, mejor que apegarse a un plan Es decir, si bien son valiosos los conceptos que aparecen en segundo lugar, valoramos más los que aparecen en primer sitio. Un manifiesto normalmente se asocia con un movimiento político emergente: ataca a la vieja guardia y sugiere un cambio revolucionario (se espera que para mejorar). En cierta forma, de eso es de lo que trata el desarrollo ágil. Aunque las ideas subyacentes que lo guían han estado durante muchos años entre nosotros, ha sido en menos de dos décadas que cristalizaron en un “movimiento”. Los métodos ágiles1 se desarrollaron como un esfuerzo por superar las debilidades reales y percibidas de la ingeniería de software convencional. El desarrollo ágil proporciona beneficios importantes, pero no es aplicable a todos los proyectos, productos, personas y situaciones. No es la antítesis de la prác- tica de la ingeniería de software sólida y puede aplicarse como filosofía general para todo el trabajo de software.

Scrum

Los principios Scrum son congruentes con el manifiesto ágil y se utilizan para guiar activida- des de desarrollo dentro de un proceso de análisis que incorpora las siguientes actividades es- tructurales: requerimientos, análisis, diseño, evolución y entrega. Dentro de cada actividad estructural, las tareas del trabajo ocurren con un patrón del proceso (que se estudia en el párrafo siguiente) llamado sprint. El trabajo realizado dentro de un sprint (el número de éstos que re- quiere cada actividad estructural variará en función de la complejidad y tamaño del producto) se adapta al problema en cuestión y se define —y con frecuencia se modifica— en tiempo real por parte del equipo Scrum. El flujo general del proceso Scrum se ilustra en la figura 3.4. Scrum acentúa el uso de un conjunto de patrones de proceso del software [Noy02] que han demostrado ser eficaces para proyectos con plazos de entrega muy apretados, requerimientos cambiantes y negocios críticos. Cada uno de estos patrones de proceso define un grupo de ac- ciones de desarrollo:

Retraso: lista de prioridades de los requerimientos o características del proyecto que dan al cliente un valor del negocio. Es posible agregar en cualquier momento otros aspectos al re- traso (ésta es la forma en la que se introducen los cambios). El gerente del proyecto evalúa el retraso y actualiza las prioridades según se requiera. Sprints: consiste en unidades de trabajo que se necesitan para alcanzar un requerimiento definido en el retraso que debe ajustarse en una caja de tiempo14 predefinida (lo común son 30 días). Durante el sprint no se introducen cambios (por ejemplo, aspectos del trabajo retra- sado). Así, el sprint permite a los miembros del equipo trabajar en un ambiente de corto plazo pero estable. Reuniones Scrum: son reuniones breves (de 15 minutos, por lo general) que el equipo Scrum efectúa a diario. Hay tres preguntas clave que se pide que respondan todos los miem- bros del equipo [Noy02]: • ¿Qué hiciste desde la última reunión del equipo? • ¿Qué obstáculos estás encontrando? • ¿Qué planeas hacer mientras llega la siguiente reunión del equipo?

Un líder del equipo, llamado maestro Scrum, dirige la junta y evalúa las respuestas de cada per- sona. La junta Scrum ayuda al equipo a descubrir los problemas potenciales tan pronto como sea posible. Asimismo, estas juntas diarias llevan a la “socialización del conocimiento” [Bee99], con lo que se promueve una estructura de equipo con organización propia. Demostraciones preliminares: entregar el incremento de software al cliente de modo que la funcionalidad que se haya implementado pueda demostrarse al cliente y éste pueda evaluarla Es importante notar que las demostraciones preliminares no contienen toda la funcionalidad planeada, sino que éstas se entregarán dentro de la caja de tiempo establecida. Beedle y sus colegas [Bee99] presentan un análisis exhaustivo de estos patrones en el que dicen: “Scrum supone de entrada la existencia de caos…” Los patrones de proceso Scrum permiten que un equipo de software trabaje con éxito en un mundo en el que es imposible eliminar la incer- tidumbre

Kanban

The concept of Kanban has been introduced at Toyota in 1947, in which this term has originated from a Japanese term denoting ‘signboard’. It is a visual process management system that can manage knowledge and work by considering the Just In Time (JIT) delivery approach. The JIT does not overload team members since the Kanban method focuses on removing bottlenecks and waste, as well as reducing waiting times, which lead to the increase of the throughputs amount (Aurisch et al., 2019; Ikonen et al., 2011)

In 2004, David J. Anderson, anticipated the Kanban as a software development method. He is considered as the father of Kanban and one of the top leaders behind the movement. He described Kanban as “an approach to incremental, evolutionary process, and systems change for organizations” (Anderson, 2010). The Agile Kanban method can enhance the understanding, visibility, and controlling of the workflow. It can help the management by identifying the bottlenecks during the development process of software projects (Alaidaros et al., 2018b; Al-Baik & Miller, 2015). This method uses the pull system as the core approach in exposing the problems of system process and to stimulate collaboration for continuously improving the system (Anderson, 2010).

Agile Kanban is a key method used for managing workflow and controlling waste in developing software projects (Alaidaros et al., 2019b). The works in the traditional methods look like a chain, whereby the work of one member is given to another and thus may cause lags in the development cycle. For instance, if a member was to have problems related to the other member’s work, his or her tasks will become overloaded. However, rather than pushing the tasks to members, the Agile Kanban method utilizes the pulling system in which all members in a team must only have one task to work on at a specific time. Once completed the given task, team member can pull another task (Banijamali et al., 2017).

Kanban Principles and PracticesAnderson (2010) has defined five principles for the Agile Kanban method, which are: a) limiting work in progress (WIP), b) visualizing workflow, c) measuring and managing the flow, d) making process policies explicit, and e) using models to recognize improvement opportunities. These principles are briefly described.a)Limiting WIP: This is a core principle of the Agile Kanban method, which is defined as the maximum count of tasks for each Kanban board stage. It is commonly identified by project manager to prevent roadblocks and make tasks move quickly on the board.b)Visualizing workflow: This is another core principle of the Kanban method, which is defined as the process of highlighting the mechanisms, interactions, waiting, queues, and delays, which are involved in implementing a part of valuable software.c)Measuring and managing the flow: This principle of measuring and managing flow highlights a focus not only on keeping a work or task moving but also on the need of using the flow as the driver for improvement. The mastering is the focus on flow rather than on waste removal. d)Making process policies explicit: This principle reflects the effectiveness and reality of a work that needs to be well defined in order to give encouragement to all team members. This is important to ensure that all team members can think on the development process as a group of policies, instead of considering workflows as a restricted technique.e)Using models to recognize improvement opportunities: The Kanban method adopts the quantitative scientific approach to create improvements. The method focuses on the models that lean towards managing waste and controlling flow by considering the Theory of Constraints (TOC). The method also tries to understand the system and variations of the profound knowledge. Besides the principles, the Agile Kanban method has four practices, which are: (a) Start with what do you have, (b) Agree to pursue incremental and evolutionary change, (c) Respect the existing roles, processes, and responsibilities, and (d) Encourage the leadership acts during the whole development process (Flora & Chande, 2014).

Agile Kanban method is significantly differ from other methods because it starts with where an organization is, and does not require the creation of new roles, ceremonies, or structures before getting started. However, limiting the WIP and visualizing the workflow are the two core principles of the Agile Kanban method that are used for monitoring the project progress.

The Agile Kanban method has a board that is used to visualize the workflow and monitor the project progress by showing the activities of the development process and keeping the WIP in control (Anderson, 2010). The Kanban board also provides the ability to concentrate on few tasks for the developers. Thus, resources and time waste would be reduced due the switching process between the tasks in Kanban board (Dennehy & Conboy, 2017). The Kanban board is the key aspect of the Agile Kanban method since the development process can be tracked (Saltz et al., 2017). Typically, the Kanban board is vertically divided into different columns or stages. Each stage refers to the task state, while each task is represented by a card attached on the board in the stage to represent the current state of tasks (Nakazawa & Tanaka, 2016). On the Kanban board, cards are moved from left to the right side based on the changes of the task’s state (Dennehy & Conboy, 2017)
